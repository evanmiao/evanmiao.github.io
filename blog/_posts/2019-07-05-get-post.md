---
title: GET 和 POST 的区别
date: 2019-07-05
tags:
  - HTTP
  - 学习笔记
summary: 要理解 GET 和 POST 的区别，本质在于语义的对比而不是语法的对比： GET 用于获取资源，安全，幂等，可缓存。 POST 用于处理资源，不安全，不幂等，不可缓存。
---

## 一般理解

- **GET通过URL传参，POST通过请求体传参。**

  HTTP协议规范里面没有强制性要求GET请求必须把数据都放URL里面，只要服务端支持，可以在请求体写参数，方法使用GET。也可以在URL上写参数，方法使用POST。
  GET请求参数附在URL之后，以?分割URL和传输数据，多个参数用&连接。同样只要服务端支持，GET方法参数写法可以自己约定。

- **GET提交到服务端的数据量小（受限于URL长度），而POST数据量大。**

  HTTP协议没有对URL的长度做规定，限制URL长度的大多是浏览器和服务器的配置参数。
  同样的，HTTP协议没有对POST进行任何限制，一般是受服务器配置限制或者内存大小。
  PHP下可以修改 php.conf 的 postmaxsize 来设置POST的大小

- **GET参数的数据类型只能是ASCII码，而POST无限制（允许二进制数据）。**

- **GET只能进行URL编码，而POST支持多种编码方式。**

  GET: application/x-www-form-urlencoded
  POST: application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。

- **GET不应用于传递敏感信息，因为参数直接暴露在URL上。**

  然而，从传输的角度来说，他们都是不安全的，因为HTTP在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文。
  要想安全传输，就只有加密，也就是HTTPS。

- **GET后退按钮/刷新无害，POST数据会被重新提交**

  浏览器应该告知用户数据会被重新提交。

- **GET请求会保存在浏览器的浏览记录中。**

- **GET请求的URL能够保存为浏览器书签。**

- **GET能被缓存，POST不能缓存。**

  GET时默认可以复用前面的请求数据作为缓存结果返回，此时以完整的URL作为缓存数据的KEY。
  所以有时候为了强制每次请求都是新数据，我们可以在URL后面加上一个随机参数Math.random或时间戳new Date().getTime()或版本号。

## 深入理解

RFC7231里定义了HTTP方法的几个性质：

- **Safe - 安全性**

  >安全性的定义：对服务端发起的请求没有引起服务端的任何状态变化，则认为符合安全性。

  注意这里指的不是上面提到的网络安全方面的安全性。
  引入安全性主要是方便爬虫和缓存，以免调用某些不安全的方法引起意外的后果。
  此RFC定义 GET HEAD OPTIONS TRACE 这几个方法是安全的。但这个定义只是规范，并不保证方法的实现也是安全的。

- **Idempotent - 幂等性**

  >幂等性的定义：一个请求执行一次和执行多次获得的结果是一致的，则认为符合幂等性。

  引入幂等性主要是为了处理一个请求重复提交的情况，比如请求响应前失去连接，如果请求方法是幂等的，就可以重新发送请求；如果请求方法不幂等，重复请求可能会带来意想不到的后果。
  此RFC定义 PUT DELETE 和安全方法都是幂等的。同样，这只是规范，并不保证服务端实现是否幂等。

- **Cacheable - 可缓存性**

  就是一个方法是否可以被缓存。
  此RFC定义 GET HEAD 和某些情况下的 POST 都是可缓存的，但大多数浏览器的实现只支持 GET 和 HEAD 。

---

这三个性质一直在强调一个事情：协议不等于实现。
可以看出，要理解 GET 和 POST 的区别，本质在于**语义**的对比而不是**语法**的对比：

>GET的语义是请求获取指定的资源。GET方法的报文主体没有任何语义。
GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）。

>POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。
POST方法是不安全、不幂等、（大部分实现）不可缓存的。

**GET用于获取资源，POST用于处理资源。**

## POST 方法会产生两个 TCP 数据包？

有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。
HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。
所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。